# LRUCache 实现说明文档

1. **数据结构**：

    - 使用双向链表维护缓存项的访问顺序，最近访问的节点位于链表头部，最久未使用的节点位于尾部。
    - 使用哈希表（`Map<string, LRUNode>`）实现 O(1) 时间的键值查找。

2. **核心操作**：

    - **`put` 方法**：
        - 如果键已存在，更新值并移动节点到头部，同时更新总容量。
        - 如果键不存在，创建新节点并插入链表头部，更新哈希表和总容量。
        - 如果总容量超过最大值，循环删除链表尾部的节点（LRU 淘汰策略）。
    - **`get` 方法**：
        - 通过哈希表查找节点，存在则将节点移动到头部并返回值，否则返回 `undefined`。

3. **容量管理**：

    - 每个节点的 `size` 为 `Buffer.byteLength`，插入或更新节点时动态调整当前总容量。
    - 当总容量超过阈值时，通过 `while` 循环确保持续淘汰节点直到满足容量要求。

4. **边界处理**：
    - 构造函数检查 `maxSize` 是否为正值。
    - 处理单个节点大小超过 `maxSize` 的情况（插入后立即被淘汰）。

### 使用示例

```typescript
// 创建最大容量为 100 字节的缓存
const cache = new LRUCache(100);

// 添加缓存项
cache.put("key1", Buffer.from("value1")); // size: 6
cache.put("key2", Buffer.from("value2")); // size: 6 (total 12)

// 读取缓存项
const value = cache.get("key1"); // 返回 Buffer，并将 key1 设为最近使用

// 添加大文件触发 LRU 淘汰
cache.put("key3", Buffer.alloc(90)); // total size: 6 + 90 = 96
cache.put("key4", Buffer.alloc(10)); // total size: 96 + 10 = 106 → 触发淘汰
// 此时 key2 被淘汰（最久未使用），总容量变为 96 - 6 + 10 = 100
```

该实现严格遵循 LRU 淘汰策略，并通过双向链表和哈希表保证了操作的高效性。

注意：

在上述代码中，使用 `WeakMap` 代替 `Map` 是不可行的，主要原因在于 `WeakMap` 和 `Map` 的特性差异：

1. **键的类型**：`WeakMap` 的键只能是对象，而不能是原始数据类型（例如字符串）。但在你的 `LRUCache` 类中，键值是字符串类型的 (`key: string`)，因此这里无法直接用 `WeakMap` 替代 `Map`。

2. **弱引用特性**：`WeakMap` 提供的是对对象的弱引用，这意味着当一个对象作为 `WeakMap` 的键时，如果这个对象没有被其他地方强引用，它就有可能被垃圾回收机制回收。然而，在缓存系统中，我们通常希望控制元素的生命周期，通过 LRU 等策略来决定哪些元素应该被移除，而不是依赖于垃圾回收机制。此外，由于 `WeakMap` 不提供诸如遍历、获取大小等操作，这使得实现像 LRU Cache 这样的功能变得更加复杂或不可能。

3. **功能限制**：`WeakMap` 缺少一些 `Map` 提供的功能，比如迭代器和获取大小的方法（如 `.size`），这些对于维护 LRU 队列和实现缓存淘汰策略是非常必要的。

综上所述，为了实现 LRU 缓存的功能，保持使用 `Map` 是更合适的选择。`Map` 能够很好地支持缓存所需要的快速查找、插入以及删除操作，并且允许以字符串作为键，非常适合你当前的需求场景。
